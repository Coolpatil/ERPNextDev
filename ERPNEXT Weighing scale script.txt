let scalePort = null;
let scaleReader = null;
let readingActive = false;

function savePortInfo(port) {
    const info = port.getInfo();
    localStorage.setItem('selectedScalePort', JSON.stringify(info));
}

async function getStoredPort() {
    const storedInfoStr = localStorage.getItem('selectedScalePort');
    if (!storedInfoStr) return null;

    const storedInfo = JSON.parse(storedInfoStr);
    const ports = await navigator.serial.getPorts();

    for (const port of ports) {
        const info = port.getInfo();
        let match = true;
        if (storedInfo.usbVendorId && info.usbVendorId !== storedInfo.usbVendorId) match = false;
        if (storedInfo.usbProductId && info.usbProductId !== storedInfo.usbProductId) match = false;
        if (storedInfo.serialNumber && info.serialNumber !== storedInfo.serialNumber) match = false;
        if (match) return port;
    }
    return null;
}

async function openPort(port) {
    if (!port.readable) {
        await port.open({ baudRate: 9600 });
    }
}

async function continuousReadWeight(frm) {
    try {
        if (!scalePort) {
            scalePort = await getStoredPort();
            if (!scalePort) {
                // Ask user to select port at first launch
                scalePort = await navigator.serial.requestPort();
                savePortInfo(scalePort);
            }
        }

        await openPort(scalePort);

        if (!scaleReader) {
            const decoder = new TextDecoderStream();
            scalePort.readable.pipeTo(decoder.writable);
            scaleReader = decoder.readable.getReader();
        }

        readingActive = true;
        let buffer = '';

        while (readingActive) {
            const { value, done } = await scaleReader.read();
            if (done) break;
            if (value) {
                buffer += value;
                if (buffer.length > 50) {
                    buffer = buffer.slice(-20);
                }

                const matched = buffer.match(/[-+]?[0-9]*\.?[0-9]+/);
                if (matched) {
                    const weight = parseFloat(matched[0]);
                    if (!isNaN(weight)) {
                        frm.set_value('weight', weight);
                        frm.refresh_field('weight');
                    }
                    buffer = ''; // Clear buffer after successful read
                }
            }
            // Small delay to prevent tight loop (optional)
            await new Promise(resolve => setTimeout(resolve, 100));
        }

    } catch (error) {
        console.error("Error during continuous read:", error);
        frappe.msgprint("Error reading weight: " + error.message);
    }
}

async function closeScalePort() {
    readingActive = false;
    if (scaleReader) {
        try { await scaleReader.cancel(); } catch {}
        try { scaleReader.releaseLock(); } catch {}
        scaleReader = null;
    }
    if (scalePort) {
        try { await scalePort.close(); } catch {}
        scalePort = null;
        localStorage.removeItem('selectedScalePort');
    }
}

frappe.ui.form.on('Weighing Scale', {
    refresh(frm) {
        frm.add_custom_button('Select COM Port', async () => {
            try {
                await closeScalePort();
                scalePort = await navigator.serial.requestPort();
                savePortInfo(scalePort);
                frappe.msgprint('COM Port selected and saved for future use.');
                continuousReadWeight(frm); // Start reading after selecting port
            } catch (error) {
                frappe.msgprint('COM Port selection cancelled or failed.');
            }
        });

        // Start continuous reading automatically on form refresh
        continuousReadWeight(frm);

        frm.on('before_close', async () => {
            await closeScalePort();
        });
    }
});
